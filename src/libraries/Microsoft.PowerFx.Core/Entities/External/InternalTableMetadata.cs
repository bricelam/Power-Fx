// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.PowerFx.Core.Types;
using Microsoft.PowerFx.Core.Utils;

namespace Microsoft.PowerFx.Core.Entities
{
    public partial class TableCapabilities
    {
        internal class InternalTableMetadata : IExternalTableMetadata
        {
            private readonly IReadOnlyDictionary<string, ColumnMetadata> _columnsByName;

            public InternalTableMetadata(string name, string displayName, bool isReadOnly, IReadOnlyList<ColumnMetadata> columns, string parameterPkColumnName = "")
            {
                Contracts.AssertNonEmpty(name);
                Contracts.AssertNonEmpty(displayName);
                Contracts.AssertValue(columns);
                Contracts.AssertAllValues(columns);
                _columnsByName = columns.ToDictionary(col => col.Name);

                Name = name;
                DisplayName = displayName;
                IsReadOnly = isReadOnly;
                Columns = columns;
                ParameterPkColumnName = parameterPkColumnName;

                var keyColumns = new HashSet<string>();
                foreach (var column in columns)
                {
                    if (!column.IsKey)
                    {
                        continue;
                    }

                    // PkColumnIsAutoGeneratedKey
                    if (column.Name == "57dfb1b5-7d79-4046-a4da-fd831d5befe1-KeyId")
                    {
                        continue;
                    }

                    keyColumns.Add(column.Name);
                }

                KeyColumns = keyColumns.ToList();
            }

            public string Name { get; }

            public string DisplayName { get; }

            public string ParameterPkColumnName { get; }

            public bool IsReadOnly { get; }

            public IReadOnlyList<string> KeyColumns { get; }

            public IReadOnlyList<ColumnMetadata> Columns { get; }

            public ColumnMetadata this[string columnName]
            {
                get
                {
                    Contracts.AssertNonEmpty(columnName);
                    return _columnsByName[columnName];
                }
            }

            public bool TryGetColumn(string columnName, out ColumnMetadata column)
            {
                Contracts.AssertNonEmpty(columnName);

                return _columnsByName.TryGetValue(columnName, out column);
            }

            /// <summary>
            /// Checks whether specified column can be included in select query option.
            /// </summary>
            /// <param name="selectColumnName"></param>
            internal bool CanIncludeSelect(string selectColumnName)
            {
                bool hasColumn = false;
                DType colType = DType.Unknown;

                if (_columnsByName.ContainsKey(selectColumnName))
                {
                    hasColumn = true;
                    colType = _columnsByName[selectColumnName].Type;
                }

                return hasColumn && !colType.IsAttachment;
            }

            /// <summary>
            /// Checks whether specified navigation column can be included in expand query option.
            /// </summary>
            /// <param name="expand"></param>
            internal bool CanIncludeExpand(IExpandInfo expand)
            {
                bool hasColumn = false;
                DType colType = DType.Unknown;

                string fieldName = expand.PolymorphicParent ?? expand.Name;

                if (_columnsByName.ContainsKey(fieldName))
                {
                    hasColumn = true;
                    colType = _columnsByName[fieldName].Type;
                }

                return hasColumn && (colType.Kind == DKind.Record || colType.Kind == DKind.DataEntity || (colType.Kind == DKind.Polymorphic && ValidatePolymorphicExpand(expand, colType)));
            }

            private bool ValidatePolymorphicExpand(IExpandInfo expand, DType colType)
            {
                if (!colType.HasPolymorphicInfo)
                {
                    return false;
                }

                if (colType.PolymorphicInfo.TargetFields.Contains(expand.Name))
                {
                    return true;
                }

                // Owner types have different metadata compared to other polymorphics,
                // they use the same field for patching but have different ones for relationships
                // which are always hard-coded to 'owning<user/team>'.
                return colType.PolymorphicInfo.TargetFields.Contains("ownerid") && (expand.Name == "owninguser" || expand.Name == "owningteam");
            }
        }
    }
}
